#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""wine_wrapper: Clean, robust wrapper executing Windows debug operations via Wine Python.

Design goals:
  * macOS tarafı sadece orkestrasyon (Python + Wine çağrısı)
  * Tüm Windows API erişimi Wine içindeki python.exe üzerinden
  * Tek geçici script üretimi, hataya dayanıklı, kolay okunur
  * Spawn başarısızsa hızlı ve açık JSON hata çıktısı + erken çıkış
  * Attach & spawn için tek giriş noktası (debug_process)
  * Sınırlı event toplama (ilk N event) / filtreleme / CSV ya da JSONL
  * Minimum bağımlılık (yalnızca stdlib)
"""

from __future__ import annotations

import os
import json
import tempfile
import subprocess
import atexit
import shutil
from typing import Optional, List


class WineWrapper:
    def __init__(self, python_exe_path: str, bottle_path: str):
        self.python_exe_path = python_exe_path
        self.bottle_path = bottle_path
        if not os.path.exists(python_exe_path):
            raise FileNotFoundError(f"Python exe not found: {python_exe_path}")
        if not os.path.exists(bottle_path):
            raise FileNotFoundError(f"Bottle path not found: {bottle_path}")
        self.temp_dir = tempfile.mkdtemp(prefix="wdb_wine_")
        # Register cleanup on exit
        atexit.register(self._cleanup)

    def _cleanup(self):
        """Clean up temporary directory on exit"""
        if hasattr(self, 'temp_dir') and os.path.exists(self.temp_dir):
            try:
                shutil.rmtree(self.temp_dir)
            except Exception:
                pass

    # ------------------------------------------------------------------
    def _create_script(self, content: str) -> str:
        with tempfile.NamedTemporaryFile('w', suffix='.py', dir=self.temp_dir, delete=False) as f:
            f.write(content)
            return f.name

    def _run_script(self, script_path: str, wait_timeout_ms: int, wall_timeout_sec: int | None) -> str:
        """Run Wine script with improved error handling and timeout management"""
        env = os.environ.copy()
        env['WINEPREFIX'] = self.bottle_path
        env['WINEDEBUG'] = '-all'  # Suppress Wine debug output for cleaner logs
        cmd = ['wine', self.python_exe_path, script_path]
        
        # Improved timeout calculation with bounds checking
        min_timeout = 30
        max_timeout = 3600  # 1 hour max
        calculated_timeout = int(max(wait_timeout_ms / 1000.0, 1)) + 10
        wall = max(min_timeout, min(max_timeout, wall_timeout_sec or calculated_timeout))
        
        try:
            proc = subprocess.run(cmd, capture_output=True, text=True, env=env, timeout=wall)
            if proc.returncode != 0:
                error_msg = proc.stderr.strip() or proc.stdout.strip() or "Unknown error"
                raise RuntimeError(f"Wine python failed (rc={proc.returncode}): {error_msg}")
            return proc.stdout
        except subprocess.TimeoutExpired:
            raise RuntimeError(f"Wine execution timed out after {wall} seconds")
        except FileNotFoundError:
            raise RuntimeError("Wine executable not found. Please ensure Wine is installed and in PATH.")
        except Exception as e:
            raise RuntimeError(f"Wine execution failed: {str(e)}")

    # ------------------------------------------------------------------
    def debug_process(self,
                      pid: Optional[int] = None,
                      spawn: Optional[str] = None,
                      spawn_args: Optional[str] = None,
                      timeout: int = 500,
                      output_file: str = 'events.jsonl',
                      csv_mode: bool = False,
                      filter_events: Optional[List[int]] = None,
                      max_events: int = 50,
                      wall_timeout: Optional[int] = None,
                      mem_bytes: int = 0,
                      extra_mem: int = 0,
                      stack_bytes: int = 0,
                      stop_on_second_chance: bool = True,
                      only_fatal: bool = False,
                      capture_context: bool = False,
                      module_summary: bool = True,
                      stream: bool = False,
                      compact: bool = False,
                      crash_triage: bool = False,
                      resolve_exports: bool = False,
                      code_window: int = 64,
                      auto_mem_on: bool = False,
                      symbolize: bool = False,
                      perf_mode: bool = False,
                      disasm: bool = False,
                      no_truncate_mem: bool = False,
                      idle_limit: int = 6) -> str:
        """Attach or spawn and capture debug events with enhanced validation"""
        
        # Input validation
        if pid is None and spawn is None:
            raise ValueError("Either pid or spawn must be specified")
        if pid is not None and spawn is not None:
            raise ValueError("Cannot specify both pid and spawn")
        if pid is not None and (pid <= 0 or pid > 2**32):
            raise ValueError(f"Invalid PID: {pid}")
        if timeout <= 0 or timeout > 60000:
            raise ValueError(f"Timeout must be between 1-60000ms: {timeout}")
        if max_events < 0 or max_events > 1000000:
            raise ValueError(f"max_events must be between 0-1000000: {max_events}")
        if idle_limit < 0 or idle_limit > 1000:
            raise ValueError(f"idle_limit must be between 0-1000: {idle_limit}")
        
        # Sanitize memory parameters with bounds
        mem_bytes_val = max(0, min(int(mem_bytes), 1048576))  # Max 1MB
        extra_mem_val = max(0, min(int(extra_mem), 1048576))
        stack_bytes_val = max(0, min(int(stack_bytes), 65536))  # Max 64KB
        code_window_val = max(0, min(int(code_window), 4096))  # Max 4KB
        
        # Generate parameter literals with proper escaping
        pid_lit = 'None' if pid is None else str(int(pid))
        spawn_lit = 'None' if spawn is None else json.dumps(spawn)
        spawn_args_lit = 'None' if spawn_args is None else json.dumps(spawn_args)
        filter_lit = 'None' if not filter_events else json.dumps([int(x) for x in filter_events])
        out_lit = json.dumps(output_file)
        lines: List[str] = [
            '# Auto-generated by WineWrapper',
            f'target_pid={pid_lit}',
            f'spawn_path={spawn_lit}',
            f'spawn_args={spawn_args_lit}',
            f'timeout_ms={int(timeout)}',
            f'max_events={int(max_events)}',
            f'want_csv={bool(csv_mode)}',
            f'filter_events={filter_lit}',
            f'out_path={out_lit}',
            f'mem_bytes={mem_bytes_val}',
            f'extra_mem={extra_mem_val}',
            f'stack_bytes={stack_bytes_val}',
            f'code_window={code_window_val}',
            f'stop_on_second_chance={str(bool(stop_on_second_chance))}',
            f'only_fatal={str(bool(only_fatal))}',
            f'capture_context={str(bool(capture_context))}',
            f'module_summary={str(bool(module_summary))}',
            f'stream={str(bool(stream))}',
            f'compact={str(bool(compact))}',
            f'crash_triage={str(bool(crash_triage))}',
            f'resolve_exports={str(bool(resolve_exports))}',
            f'auto_mem_on={str(bool(auto_mem_on))}',
            f'symbolize={str(bool(symbolize))}',
            f'perf_mode={str(bool(perf_mode))}',
            f'disasm={str(bool(disasm))}',
            f'no_truncate_mem={str(bool(no_truncate_mem))}',
            f'idle_limit={int(idle_limit)}',
            ''
        ]
        body_lines = [
            'import ctypes as C, ctypes.wintypes as W, json, sys, csv',
            'from datetime import datetime',
            'import math',
            '',
            'DBG_CONTINUE=0x00010002',
            'DEBUG_ONLY_THIS_PROCESS=0x00000002',
            '# Avoid CREATE_NEW_CONSOLE to reduce display related crashes',
            'CREATE_FLAGS=DEBUG_ONLY_THIS_PROCESS',
            'EXCEPTION_DEBUG_EVENT=1;CREATE_THREAD_DEBUG_EVENT=2;CREATE_PROCESS_DEBUG_EVENT=3;EXIT_THREAD_DEBUG_EVENT=4',
            'EXIT_PROCESS_DEBUG_EVENT=5;LOAD_DLL_DEBUG_EVENT=6;UNLOAD_DLL_DEBUG_EVENT=7;OUTPUT_DEBUG_STRING_EVENT=8;RIP_EVENT=9',
            "EVENT_NAMES={1:'EXCEPTION',2:'CREATE_THREAD',3:'CREATE_PROCESS',4:'EXIT_THREAD',5:'EXIT_PROCESS',6:'LOAD_DLL',7:'UNLOAD_DLL',8:'DEBUG_STRING',9:'RIP'}",
            '',
            '# --- Debug info structures ---',
            'EXCEPTION_MAXIMUM_PARAMETERS=15',
            '# Define pointer-sized unsigned integer type (no wintypes.ULONG_PTR in some Wine builds)',
            'PTR_T = C.c_uint64 if C.sizeof(C.c_void_p)==8 else C.c_uint32',
            'class EXCEPTION_RECORD(C.Structure):',
            "    _fields_=[('ExceptionCode',W.DWORD),('ExceptionFlags',W.DWORD),('ExceptionRecord',W.LPVOID),('ExceptionAddress',W.LPVOID),('NumberParameters',W.DWORD),('ExceptionInformation',PTR_T*15)]",
            'class EXCEPTION_DEBUG_INFO(C.Structure):',
            "    _fields_=[('ExceptionRecord',EXCEPTION_RECORD),('dwFirstChance',W.DWORD)]",
            'class CREATE_PROCESS_DEBUG_INFO(C.Structure):',
            "    _fields_=[('hFile',W.HANDLE),('hProcess',W.HANDLE),('hThread',W.HANDLE),('lpBaseOfImage',W.LPVOID),('dwDebugInfoFileOffset',W.DWORD),('nDebugInfoSize',W.DWORD),('lpThreadLocalBase',W.LPVOID),('lpStartAddress',W.LPVOID),('lpImageName',W.LPVOID),('fUnicode',W.WORD)]",
            'class LOAD_DLL_DEBUG_INFO(C.Structure):',
            "    _fields_=[('hFile',W.HANDLE),('lpBaseOfDll',W.LPVOID),('dwDebugInfoFileOffset',W.DWORD),('nDebugInfoSize',W.DWORD),('lpImageName',W.LPVOID),('fUnicode',W.WORD)]",
            'class EXIT_PROCESS_DEBUG_INFO(C.Structure):',
            "    _fields_=[('dwExitCode',W.DWORD)]",
            'class UNLOAD_DLL_DEBUG_INFO(C.Structure):',
            "    _fields_=[('lpBaseOfDll',W.LPVOID)]",
            'class OUTPUT_DEBUG_STRING_INFO(C.Structure):',
            "    _fields_=[('lpDebugStringData',W.LPVOID),('fUnicode',W.WORD),('nDebugStringLength',W.WORD)]",
            'class RIP_INFO(C.Structure):',
            "    _fields_=[('dwError',W.DWORD),('dwType',W.DWORD)]",
            'class CREATE_THREAD_DEBUG_INFO(C.Structure):',
            "    _fields_=[('hThread',W.HANDLE),('lpThreadLocalBase',W.LPVOID),('lpStartAddress',W.LPVOID)]",
            'class EXIT_THREAD_DEBUG_INFO(C.Structure):',
            "    _fields_=[('dwExitCode',W.DWORD)]",
            'class _U(C.Union):',
            "    _fields_=[('Exception',EXCEPTION_DEBUG_INFO),('CreateThread',CREATE_THREAD_DEBUG_INFO),('CreateProcessInfo',CREATE_PROCESS_DEBUG_INFO),('ExitThread',EXIT_THREAD_DEBUG_INFO),('ExitProcess',EXIT_PROCESS_DEBUG_INFO),('LoadDll',LOAD_DLL_DEBUG_INFO),('UnloadDll',UNLOAD_DLL_DEBUG_INFO),('DebugString',OUTPUT_DEBUG_STRING_INFO),('RipInfo',RIP_INFO)]",
            'class DEBUG_EVENT(C.Structure):',
            "    _anonymous_=['u']",
            "    _fields_=[('dwDebugEventCode',W.DWORD),('dwProcessId',W.DWORD),('dwThreadId',W.DWORD),('u',_U)]",
            'class STARTUPINFOW(C.Structure):',
            "    _fields_=[('cb',W.DWORD),('lpReserved',W.LPWSTR),('lpDesktop',W.LPWSTR),('lpTitle',W.LPWSTR),('dwX',W.DWORD),('dwY',W.DWORD),('dwXSize',W.DWORD),('dwYSize',W.DWORD),('dwXCountChars',W.DWORD),('dwYCountChars',W.DWORD),('dwFillAttribute',W.DWORD),('dwFlags',W.DWORD),('wShowWindow',W.WORD),('cbReserved2',W.WORD),('lpReserved2',C.POINTER(C.c_byte)),('hStdInput',W.HANDLE),('hStdOutput',W.HANDLE),('hStdError',W.HANDLE)]",
            'class PROCESS_INFORMATION(C.Structure):',
            "    _fields_=[('hProcess',W.HANDLE),('hThread',W.HANDLE),('dwProcessId',W.DWORD),('dwThreadId',W.DWORD)]",
            '',
            '# (Partial) 32-bit CONTEXT for WOW64 register capture (simplified)',
            'class CONTEXT32(C.Structure):',
            "    _fields_=[('ContextFlags',W.DWORD),('Dr0',W.DWORD),('Dr1',W.DWORD),('Dr2',W.DWORD),('Dr3',W.DWORD),('Dr6',W.DWORD),('Dr7',W.DWORD),('FloatSave',C.c_byte*112),('SegGs',W.DWORD),('SegFs',W.DWORD),('SegEs',W.DWORD),('SegDs',W.DWORD),('Edi',W.DWORD),('Esi',W.DWORD),('Ebx',W.DWORD),('Edx',W.DWORD),('Ecx',W.DWORD),('Eax',W.DWORD),('Ebp',W.DWORD),('Eip',W.DWORD),('SegCs',W.DWORD),('EFlags',W.DWORD),('Esp',W.DWORD),('SegSs',W.DWORD),('ExtendedRegisters',C.c_byte*512)]",
            'kernel32=C.windll.kernel32',
            'kernel32.WaitForDebugEvent.argtypes=[C.POINTER(DEBUG_EVENT),W.DWORD]; kernel32.WaitForDebugEvent.restype=W.BOOL',
            'kernel32.ContinueDebugEvent.argtypes=[W.DWORD,W.DWORD,W.DWORD]; kernel32.ContinueDebugEvent.restype=W.BOOL',
            'kernel32.DebugActiveProcess.argtypes=[W.DWORD]; kernel32.DebugActiveProcess.restype=W.BOOL',
            'kernel32.GetFileAttributesW.restype=W.DWORD',
            'kernel32.OpenProcess.argtypes=[W.DWORD,W.BOOL,W.DWORD]; kernel32.OpenProcess.restype=W.HANDLE',
            'kernel32.ReadProcessMemory.argtypes=[W.HANDLE,W.LPCVOID,W.LPVOID,C.c_size_t,C.POINTER(C.c_size_t)]; kernel32.ReadProcessMemory.restype=W.BOOL',
            'kernel32.OpenThread.argtypes=[W.DWORD,W.BOOL,W.DWORD]; kernel32.OpenThread.restype=W.HANDLE',
            'kernel32.GetThreadContext.argtypes=[W.HANDLE, C.c_void_p]; kernel32.GetThreadContext.restype=W.BOOL',
            'kernel32.Wow64GetThreadContext.argtypes=[W.HANDLE, C.POINTER(CONTEXT32)]; kernel32.Wow64GetThreadContext.restype=W.BOOL',
            'kernel32.SuspendThread.argtypes=[W.HANDLE]; kernel32.SuspendThread.restype=W.DWORD',
            'kernel32.ResumeThread.argtypes=[W.HANDLE]; kernel32.ResumeThread.restype=W.DWORD',
            '',
            '# Optional helper to read image name via lpImageName if available',
            'def _safe_image_name(ptr, f_unicode):',
            '    try:',
            '        if not ptr: return None',
            '        # ptr is LPVOID pointing to pointer-to-string (per spec) so double indirection',
            '        name_ptr = C.cast(ptr, C.POINTER(W.LPVOID)).contents.value',
            '        if not name_ptr: return None',
            '        if f_unicode:',
            '            return C.wstring_at(name_ptr)',
            '        else:',
            '            return C.string_at(name_ptr).decode(errors="ignore")',
            '    except Exception:',
            '        return None',
            '',
            'def file_exists(path:str)->bool:',
            "    if not path or path in ('None',): return False",
            '    return kernel32.GetFileAttributesW(path)!=0xFFFFFFFF',
            '',
            'events=[]',
            'start_ts=datetime.utcnow()',
            'modules=[]  # list of dicts: {base:int,path:str}',
            'exports_cache={}',
            'proc_handle=None',
            'def _record_module(path, base_hex):',
            '    try:',
            '        base=int(base_hex,16)',
            '        modules.append({"base":base,"path":path})',
            '    except Exception: pass',
            'def _find_module(addr):',
            '    best=None; best_base=-1',
            '    for m in modules:',
            '        b=m["base"]',
            '        if b<=addr and b>best_base: best_base=b; best=m',
            '    return best',
            'EXCODES={0x80000003:"BREAKPOINT",0xC0000005:"ACCESS_VIOLATION",0xC000001D:"ILLEGAL_INSTRUCTION",0xC0000094:"INT_DIVIDE_BY_ZERO",0xC00000FD:"STACK_OVERFLOW",0xC0000409:"FAST_FAIL",0x80000001:"GUARD_PAGE",0x80000002:"DATATYPE_MISALIGNMENT",0x80000004:"SINGLE_STEP",0xC0000006:"IN_PAGE_ERROR",0xC0000008:"INVALID_HANDLE",0xC000008C:"ARRAY_BOUNDS_EXCEEDED",0xC000008D:"FLOAT_DENORMAL_OPERAND",0xC000008E:"FLOAT_DIVIDE_BY_ZERO",0xC000008F:"FLOAT_INEXACT_RESULT",0xC0000090:"FLOAT_INVALID_OPERATION",0xC0000091:"FLOAT_OVERFLOW",0xC0000092:"FLOAT_STACK_CHECK",0xC0000093:"FLOAT_UNDERFLOW",0xC0000095:"INTEGER_OVERFLOW",0xC0000096:"PRIVILEGED_INSTRUCTION",0xC0000135:"DLL_NOT_FOUND",0xC0000138:"ORDINAL_NOT_FOUND",0xC0000139:"ENTRYPOINT_NOT_FOUND",0xC000013A:"CONTROL_C_EXIT",0xC000041D:"FATAL_USER_CALLBACK_EXCEPTION",0xC0000420:"ASSERTION_FAILURE"}',
            '',
            '# Enhanced PE export parser with caching and bounds checking',
            'def _parse_exports(path):',
            '    if not resolve_exports: return None',
            '    if path in exports_cache: return exports_cache.get(path)',
            '    try:',
            '        # File size check to prevent memory issues',
            '        try:',
            '            file_size = os.path.getsize(path)',
            '            if file_size > 100*1024*1024: exports_cache[path]=None; return None  # Skip files >100MB',
            '        except Exception: pass',
            '        with open(path, "rb") as f:',
            '            mz=f.read(64)',
            '            if len(mz)<64 or mz[:2]!=b"MZ": exports_cache[path]=None; return None',
            '            f.seek(0x3C); pe_off_bytes=f.read(4)',
            '            if len(pe_off_bytes)<4: exports_cache[path]=None; return None',
            '            pe_off=int.from_bytes(pe_off_bytes,"little")',
            '            if pe_off<=0 or pe_off>file_size-4: exports_cache[path]=None; return None',
            '            f.seek(pe_off); sig=f.read(4)',
            '            if len(sig)<4 or sig[:2]!=b"PE": exports_cache[path]=None; return None',
            '            file_header=f.read(20)',
            '            if len(file_header)<20: exports_cache[path]=None; return None',
            '            num_sections=int.from_bytes(file_header[2:4],"little")',
            '            if num_sections > 96: exports_cache[path]=None; return None  # Sanity check',
            '            size_opt=int.from_bytes(file_header[16:18],"little")',
            '            if size_opt > 4096: exports_cache[path]=None; return None  # Sanity check',
            '            opt=f.read(size_opt)',
            '            if len(opt)<size_opt or size_opt<96: exports_cache[path]=None; return None',
            '            magic=int.from_bytes(opt[0:2],"little")',
            '            data_dir_off=96 if magic==0x10B else (112 if magic==0x20B else None)',
            '            if data_dir_off is None or size_opt < data_dir_off+8: exports_cache[path]=None; return None',
            '            export_rva=int.from_bytes(opt[data_dir_off:data_dir_off+4],"little")',
            '            export_size=int.from_bytes(opt[data_dir_off+4:data_dir_off+8],"little")',
            '            if export_rva==0 or export_size==0: exports_cache[path]=None; return None',
            '            # Read section table with bounds checking',
            '            f.seek(pe_off+4+20+size_opt)',
            '            sec_tbl=[]',
            '            for _ in range(min(num_sections, 96)):',  # Limit sections
            '                sh=f.read(40)',
            '                if len(sh)<40: break',
            '                va=int.from_bytes(sh[12:16],"little")',
            '                vs=int.from_bytes(sh[8:12],"little")',
            '                raw_ptr=int.from_bytes(sh[20:24],"little")',
            '                if va > 0x80000000 or vs > 0x10000000 or raw_ptr > file_size: continue  # Skip invalid',
            '                sec_tbl.append((va,va+vs,raw_ptr))',
            '            def rva_to_off(rva):',
            '                for a,b,ptr in sec_tbl:',
            '                    if a<=rva<b: return ptr+(rva-a)',
            '                return None',
            '            exp_off=rva_to_off(export_rva)',
            '            if exp_off is None or exp_off > file_size-40: exports_cache[path]=None; return None',
            '            f.seek(exp_off)',
            '            ed=f.read(40)',
            '            if len(ed)<40: exports_cache[path]=None; return None',
            '            n_funcs=int.from_bytes(ed[20:24],"little")',
            '            n_names=int.from_bytes(ed[24:28],"little")',
            '            # Sanity check export counts',
            '            if n_funcs > 65536 or n_names > 65536: exports_cache[path]=None; return None',
            '            addr_funcs_rva=int.from_bytes(ed[28:32],"little")',
            '            addr_names_rva=int.from_bytes(ed[32:36],"little")',
            '            addr_ord_rva=int.from_bytes(ed[36:40],"little")',
            '            fn_off=rva_to_off(addr_funcs_rva); names_off=rva_to_off(addr_names_rva); ord_off=rva_to_off(addr_ord_rva)',
            '            if None in (fn_off,names_off,ord_off): exports_cache[path]=None; return None',
            '            # Read with reasonable limits',
            '            f.seek(names_off); name_rvas=[int.from_bytes(f.read(4),"little") for _ in range(min(n_names,4096))]',
            '            f.seek(ord_off); ordinals=[int.from_bytes(f.read(2),"little") for _ in range(min(n_names,4096))]',
            '            f.seek(fn_off); fn_rvas=[int.from_bytes(f.read(4),"little") for _ in range(min(n_funcs,16384))]',
            '            result={}',
            '            lim=min(len(name_rvas),len(ordinals),1024)  # Limit to 1024 exports',
            '            for i in range(lim):',
            '                nrva=name_rvas[i]',
            '                noff=rva_to_off(nrva)',
            '                if noff is None or noff > file_size-1: continue',
            '                f.seek(noff); name_bytes=[]',
            '                for _ in range(256):  # Max name length',
            '                    ch=f.read(1)',
            '                    if not ch: break',
            '                    v=ch[0]',
            '                    if v in (0,10,13): break',
            '                    name_bytes.append(ch)',
            '                if not name_bytes: continue',
            '                name=b"".join(name_bytes).decode(errors="ignore")',
            '                ord_idx=ordinals[i]',
            '                if ord_idx < len(fn_rvas):',
            '                    result[name]=fn_rvas[ord_idx]',
            '            exports_cache[path]=result if result else None',
            '            return exports_cache[path]',
            '    except Exception:',
            '        exports_cache[path]=None; return None',
            '    return None',
            '',
            'def spawn_proc(exe, a):',
            '    if not file_exists(exe):',
            "        print(json.dumps({'error':'file_not_found','exe':exe})); return None",
            '    si=STARTUPINFOW(); si.cb=C.sizeof(STARTUPINFOW)',
            '    pi=PROCESS_INFORMATION()',
            "    cmd='\"'+exe+'\"'+(' '+a if a and a not in ('None',) else '')",
            '    buf=C.create_unicode_buffer(cmd)',
            '    CP=kernel32.CreateProcessW; CP.argtypes=[W.LPCWSTR,W.LPWSTR,C.c_void_p,C.c_void_p,W.BOOL,W.DWORD,C.c_void_p,W.LPCWSTR,C.POINTER(STARTUPINFOW),C.POINTER(PROCESS_INFORMATION)]; CP.restype=W.BOOL',
            '    if not CP(None, buf, None, None, False, CREATE_FLAGS, None, None, C.byref(si), C.byref(pi)):',
            "        print(json.dumps({'error':'CreateProcessW','code':kernel32.GetLastError(),'cmd':cmd})); return None",
            "    print(json.dumps({'info':'spawn_ok','pid':pi.dwProcessId}))",
            '    return pi',
            '',
            'attached=False',
            "if target_pid not in (None,'None'):",
            '    if kernel32.DebugActiveProcess(int(target_pid)):',
            "        attached=True; print(json.dumps({'info':'attach_ok','pid':int(target_pid)}))",
            '        # obtain process handle for memory reads',
            '        proc_handle=kernel32.OpenProcess(0x0410, False, int(target_pid))  # QUERY_INFORMATION | VM_READ',
            '    else:',
            "        print(json.dumps({'error':'DebugActiveProcess','code':kernel32.GetLastError(),'pid':target_pid}))",
            "elif spawn_path not in (None,'None'):",
            '    if spawn_proc(spawn_path, spawn_args): attached=True',
            'else:',
            "    print(json.dumps({'error':'no_target'}))",
            '',
            'if not attached:',
            '    # Nothing to debug; exit early',
            '    sys.stdout.flush(); sys.exit(0)',
            '',
            'dbg=DEBUG_EVENT(); seen=0; timeouts=0',
            "flt=None if filter_events in (None,'None') else set(filter_events)",
            '# If streaming, truncate output file now so we can append each event safely',
            'if stream:',
            '    try:',
            '        open(out_path, "w", encoding="utf-8").close()',
            '    except Exception: pass',
            'while seen<max_events and (idle_limit==0 or timeouts<idle_limit):',
            '    ok = kernel32.WaitForDebugEvent(C.byref(dbg), timeout_ms)',
            '    if not ok:',
            '        timeouts+=1',
            '        continue',
            '    code=dbg.dwDebugEventCode',
            '    include = (flt is None or code in flt)',
            '    # if only_fatal: skip first-chance exceptions',
            '    if code==EXCEPTION_DEBUG_EVENT and only_fatal and dbg.u.Exception.dwFirstChance==1:',
            '        kernel32.ContinueDebugEvent(dbg.dwProcessId, dbg.dwThreadId, DBG_CONTINUE); continue',
            '    if include:',
            "        base_event={'ts':datetime.utcnow().isoformat()+'Z','event':EVENT_NAMES.get(code,'UNK_'+str(code)),'code':code,'pid':dbg.dwProcessId,'tid':dbg.dwThreadId}",
            '        if compact:',
            "            base_event={'t':base_event['ts'],'e':base_event['event'],'c':base_event['code'],'p':base_event['pid'],'i':base_event['tid']}",
            '        try:',
            '            if code==CREATE_PROCESS_DEBUG_EVENT:',
            '                cp=dbg.u.CreateProcessInfo',
            '                base=C.cast(cp.lpBaseOfImage,C.c_void_p).value or 0',
            '                start=C.cast(cp.lpStartAddress,C.c_void_p).value or 0',
            '                path=None',
            '                if cp.hFile:',
            '                    GetFP=getattr(kernel32, "GetFinalPathNameByHandleW", None)',
            '                    if GetFP:',
            '                        buf=C.create_unicode_buffer(1024)',
            '                        if GetFP(cp.hFile, buf, 1024, 0)>0:',
            '                            rawp=buf.value',
            '                            path=rawp.replace("\\\\?\\\\","") if rawp else None',
            '                if path is None:',
            '                    path=_safe_image_name(cp.lpImageName, cp.fUnicode)',
            '                base_event.update({"image_path":path,"base":f"0x{base:016X}","start":f"0x{start:016X}"})',
            '                if path: base_event["module_short"]=path.split("\\\\")[-1]',
            '                if path: _record_module(path, f"0x{base:016X}")',
            '                if resolve_exports and path:',
            '                    ex=_parse_exports(path)',
            '                    if ex:',
            '                        _ek=list(ex.keys())',
            '                        base_event["export_count"]=len(_ek)',
            '                        base_event["export_sample"]=_ek[:20]',
            '                proc_handle=cp.hProcess',
            '            elif code==LOAD_DLL_DEBUG_EVENT:',
            '                ld=dbg.u.LoadDll',
            '                base=C.cast(ld.lpBaseOfDll,C.c_void_p).value or 0',
            '                path=None',
            '                if ld.hFile:',
            '                    GetFP=getattr(kernel32, "GetFinalPathNameByHandleW", None)',
            '                    if GetFP:',
            '                        buf=C.create_unicode_buffer(1024)',
            '                        if GetFP(ld.hFile, buf, 1024, 0)>0:',
            '                            rawp=buf.value',
            '                            path=rawp.replace("\\\\?\\\\","") if rawp else None',
            '                if path is None:',
            '                    path=_safe_image_name(ld.lpImageName, ld.fUnicode)',
            '                base_event.update({"dll_path":path,"base":f"0x{base:016X}"})',
            '                if path: base_event["module_short"]=path.split("\\\\")[-1]',
            '                if path: _record_module(path, f"0x{base:016X}")',
            '                if resolve_exports and path:',
            '                    ex=_parse_exports(path)',
            '                    if ex:',
            '                        _ek=list(ex.keys())',
            '                        base_event["export_count"]=len(_ek)',
            '                        base_event["export_sample"]=_ek[:20]',
            '            elif code==EXIT_PROCESS_DEBUG_EVENT:',
            '                base_event.update({"exit_code":int(dbg.u.ExitProcess.dwExitCode)})',
            '            elif code==EXCEPTION_DEBUG_EVENT:',
            '                ex=dbg.u.Exception',
            '                er=ex.ExceptionRecord',
            '                addr=C.cast(er.ExceptionAddress,C.c_void_p).value or 0',
            '                code_v=int(er.ExceptionCode)',
            '                if compact:',
            '                    base_event.update({"xc":code_v,"xn":EXCODES.get(code_v),"fc":int(ex.dwFirstChance),"xa":f"0x{addr:016X}"})',
            '                else:',
            '                    base_event.update({"exception_code":code_v,"exception_name":EXCODES.get(code_v),"first_chance":int(ex.dwFirstChance),"exception_address":f"0x{addr:016X}"})',
            '                mod=_find_module(addr)',
            '                if mod:',
            '                    if compact:',
            '                        base_event["m"]=mod["path"]',
            '                    else:',
            '                        base_event["module"]=mod["path"]',
            '                    try:',
            '                        off="0x%06X" % (addr - mod["base"])',
            '                        if compact: base_event["mo"]=off',
            '                        else: base_event["module_offset"]=off',
                '                        base_event["module_short"]=mod["path"].split("\\\\")[-1]',
            '                        if symbolize and resolve_exports:',
            '                            ex=_parse_exports(mod["path"]) if mod.get("path") else None',
            '                            if ex:',
            '                                # find nearest export rva to (addr-mod_base)',
            '                                rel=(addr - mod["base"]) & 0xFFFFFFFF',
            '                                best=None; bestd=1<<60',
            '                                for _n,_rva in ex.items():',
            '                                    d=rel-_rva',
            '                                    if d>=0 and d<bestd: bestd=d; best=_n',
            '                                if best is not None:',
            '                                    base_event["symbol_name"]=best',
            '                                    base_event["symbol_offset"]="0x%X" % bestd',
            '                    except Exception: pass',
            '                # dump exception info parameters (up to NumberParameters)',
            '                n=min(int(er.NumberParameters),15)',
            '                if n>0:',
            '                    params=[int(er.ExceptionInformation[i]) for i in range(n)]',
            '                    if compact: base_event["xp"]=params',
            '                    else: base_event["exception_params"]=params',
            '                    # Access violation enrichment (type + fault address)',
            '                    if code_v==0xC0000005:',
            '                        try:',
            '                            if n>0:',
            '                                t=params[0]; av_map={0:"read",1:"write",8:"execute"}; tt=av_map.get(t)',
            '                                if tt: base_event["av_type"]=tt',
            '                            if n>1:',
            '                                base_event["av_address"]=f"0x{params[1]:016X}"',
            '                        except Exception: pass',
            '                # capture register context (WOW64 32-bit) if requested',
            '                if capture_context:',
            '                    try:',
            '                        # WOW64 path: host 64-bit, target 32-bit => use Wow64GetThreadContext',
            '                        if C.sizeof(C.c_void_p)==8:',
            '                            TH_ACCESS=0x0010 | 0x0008  # SUSPEND_RESUME | GET_CONTEXT',
            '                            hThread=kernel32.OpenThread(TH_ACCESS, False, dbg.dwThreadId)',
            '                            if hThread:',
            '                                suspended=False',
            '                                try:',
            '                                    if kernel32.SuspendThread(hThread)!=0xFFFFFFFF: suspended=True',
            '                                    # Try WOW64 (32-bit) first',
            '                                    ctx32=CONTEXT32(); ctx32.ContextFlags=0x00010007',
            '                                    got32=False',
            '                                    if hasattr(kernel32, "Wow64GetThreadContext"):',
            '                                        got32 = bool(kernel32.Wow64GetThreadContext(hThread, C.byref(ctx32)))',
            '                                    if got32:',
            '                                        base_event["context"]={"EAX":ctx32.Eax,"EBX":ctx32.Ebx,"ECX":ctx32.Ecx,"EDX":ctx32.Edx,"ESI":ctx32.Esi,"EDI":ctx32.Edi,"EBP":ctx32.Ebp,"ESP":ctx32.Esp,"EIP":ctx32.Eip,"EFLAGS":ctx32.EFlags}',
            '                                    else:',
            '                                        # Native 64-bit fallback',
            '                                        try:',
            '                                            ctx64=CONTEXT64(); ctx64.ContextFlags=0x0010003F',
            '                                            if kernel32.GetThreadContext(hThread, C.byref(ctx64)):',
            '                                                base_event["context64"]={"RAX":ctx64.Rax,"RBX":ctx64.Rbx,"RCX":ctx64.Rcx,"RDX":ctx64.Rdx,"RSI":ctx64.Rsi,"RDI":ctx64.Rdi,"RBP":ctx64.Rbp,"RSP":ctx64.Rsp,"R8":ctx64.R8,"R9":ctx64.R9,"R10":ctx64.R10,"R11":ctx64.R11,"R12":ctx64.R12,"R13":ctx64.R13,"R14":ctx64.R14,"R15":ctx64.R15,"RIP":ctx64.Rip,"EFLAGS":ctx64.EFlags}',
            '                                            else:',
            '                                                base_event["context_error"]="ctx64_fail"',
            '                                        except Exception as _c64:',
            '                                            base_event["context_error"]=str(_c64)',
            '                                finally:',
            '                                    if suspended: kernel32.ResumeThread(hThread)',
            '                        else:',
            '                            # Pure 32-bit process (native) or host 32-bit: use GetThreadContext directly',
            '                            TH_ACCESS=0x0010 | 0x0008',
            '                            hThread=kernel32.OpenThread(TH_ACCESS, False, dbg.dwThreadId)',
            '                            if hThread:',
            '                                ctx=CONTEXT32(); ctx.ContextFlags=0x00010007',
            '                                if kernel32.GetThreadContext(hThread, C.byref(ctx)):',
            '                                    base_event["context"]={"EAX":ctx.Eax,"EBX":ctx.Ebx,"ECX":ctx.Ecx,"EDX":ctx.Edx,"ESI":ctx.Esi,"EDI":ctx.Edi,"EBP":ctx.Ebp,"ESP":ctx.Esp,"EIP":ctx.Eip,"EFLAGS":ctx.EFlags}',
            '                                else: base_event["context_error"]="ctx_fail_native"',
            '                    except Exception as _ce: base_event["context_error"]=str(_ce)',
            '                # optional memory sample',
            '                if not perf_mode and mem_bytes>0 and proc_handle and code_v!=0:',
            '                    try:',
            '                        sz=min(mem_bytes,65536 if no_truncate_mem else 4096)',
            '                        buf=(C.c_ubyte*sz)()',
            '                        read=C.c_size_t()',
            '                        if kernel32.ReadProcessMemory(proc_handle, C.c_void_p(addr), buf, sz, C.byref(read)) and read.value>0:',
            '                            data_bytes=bytes(buf[:read.value])',
            '                            preview=read.value if no_truncate_mem else min(read.value,128)',
            '                            base_event["mem_len"]=int(read.value)',
            '                            if read.value>preview:',
            '                                base_event["mem_hex"]="".join(f"{b:02X}" for b in data_bytes[:preview])',
            '                                base_event["mem_preview_len"]=preview',
            '                                base_event["mem_total_len"]=int(read.value)',
            '                                base_event["mem_truncated"]=1',
            '                                try:',
            '                                    dump_path=f"{out_path}.mem_{seen}_{addr:016X}.bin"',
            '                                    open(dump_path,"wb").write(data_bytes)',
            '                                    base_event["mem_dump_file"]=dump_path',
            '                                except Exception as _de: base_event["mem_dump_error"]=str(_de)',
            '                            else:',
            '                                base_event["mem_hex"]="".join(f"{b:02X}" for b in data_bytes)',
            '                    except Exception as _me: base_event["mem_error"]=str(_me)',
            '                # extra code window around exception (discrete raw bytes) if not truncated logic reused',
            '                if not perf_mode and proc_handle and code_v!=0 and mem_bytes>0:',
            '                    try:',
            '                        # code_window total split half-half (floor to before)',
            '                        total=code_window if code_window>0 else 64',
            '                        win_before=total//2; win_after=total-win_before',
            '                        win_addr=addr-win_before',
            '                        do_disasm = (not perf_mode) and disasm and (win_before+win_after)<=512',
            '                        win_size=win_before+win_after',
            '                        buf2=(C.c_ubyte*win_size)()',
            '                        read2=C.c_size_t()',
            '                        if kernel32.ReadProcessMemory(proc_handle, C.c_void_p(win_addr), buf2, win_size, C.byref(read2)) and read2.value>0:',
            '                            data2=bytes(buf2[:read2.value])',
            '                            base_event["code_window_base"]=f"0x{win_addr:016X}"',
            '                            hex_str="".join(f"{b:02X}" for b in data2)',
            '                            base_event["code_window_hex"]=hex_str',
            '                            if do_disasm:',
            '                                # Advanced x86 disassembly - inline implementation',
            '                                try:',
            '                                    # Helper functions',
            '                                    def decode_modrm_simple(modrm, data, offset):',
            '                                        registers_32 = ["EAX", "ECX", "EDX", "EBX", "ESP", "EBP", "ESI", "EDI"]',
            '                                        mod = (modrm >> 6) & 3',
            '                                        reg = (modrm >> 3) & 7',
            '                                        rm = modrm & 7',
            '                                        consumed = 0',
            '                                        if mod == 3:',
            '                                            return registers_32[rm], consumed',
            '                                        elif mod == 0:',
            '                                            if rm == 5 and offset + 4 <= len(data):',
            '                                                disp = int.from_bytes(data[offset:offset+4], "little")',
            '                                                return f"[0x{disp:08X}]", 4',
            '                                            else:',
            '                                                return f"[{registers_32[rm]}]", consumed',
            '                                        elif mod == 1 and offset + 1 <= len(data):',
            '                                            disp = int.from_bytes(data[offset:offset+1], "little", signed=True)',
            '                                            return f"[{registers_32[rm]}{disp:+d}]", 1',
            '                                        elif mod == 2 and offset + 4 <= len(data):',
            '                                            disp = int.from_bytes(data[offset:offset+4], "little", signed=True)',
            '                                            return f"[{registers_32[rm]}{disp:+d}]", 4',
            '                                        return "[?]", 0',
            '                                    ',
            '                                    def disasm_single_instruction(data, address):',
            '                                        if not data: return None',
            '                                        registers_32 = ["EAX", "ECX", "EDX", "EBX", "ESP", "EBP", "ESI", "EDI"]',
            '                                        original_data = data',
            '                                        offset = 0',
            '                                        ',
            '                                        # Skip prefixes',
            '                                        while offset < len(data) and data[offset] in [0x66, 0x67, 0xF0, 0xF2, 0xF3]:',
            '                                            offset += 1',
            '                                        if offset >= len(data): return None',
            '                                        ',
            '                                        opcode = data[offset]',
            '                                        offset += 1',
            '                                        length = offset',
            '                                        ',
            '                                        # Decode common instructions',
            '                                        if opcode == 0x90:',
            '                                            return {"addr": address, "bytes": "".join(f"{b:02X}" for b in original_data[:length]), "mnemonic": "NOP", "operands": "", "flow": "sequential"}',
            '                                        elif opcode == 0xC3:',
            '                                            return {"addr": address, "bytes": "".join(f"{b:02X}" for b in original_data[:length]), "mnemonic": "RET", "operands": "", "flow": "return"}',
            '                                        elif opcode == 0xCC:',
            '                                            return {"addr": address, "bytes": "".join(f"{b:02X}" for b in original_data[:length]), "mnemonic": "INT3", "operands": "", "flow": "interrupt"}',
            '                                        elif 0x50 <= opcode <= 0x57:',
            '                                            reg = registers_32[opcode - 0x50]',
            '                                            return {"addr": address, "bytes": "".join(f"{b:02X}" for b in original_data[:length]), "mnemonic": "PUSH", "operands": reg, "flow": "sequential"}',
            '                                        elif 0x58 <= opcode <= 0x5F:',
            '                                            reg = registers_32[opcode - 0x58]',
            '                                            return {"addr": address, "bytes": "".join(f"{b:02X}" for b in original_data[:length]), "mnemonic": "POP", "operands": reg, "flow": "sequential"}',
            '                                        elif 0xB8 <= opcode <= 0xBF and offset + 4 <= len(data):',
            '                                            reg = registers_32[opcode - 0xB8]',
            '                                            imm = int.from_bytes(data[offset:offset+4], "little")',
            '                                            length = offset + 4',
            '                                            return {"addr": address, "bytes": "".join(f"{b:02X}" for b in original_data[:length]), "mnemonic": "MOV", "operands": f"{reg}, 0x{imm:08X}", "flow": "sequential"}',
            '                                        elif opcode == 0xE8 and offset + 4 <= len(data):',
            '                                            disp = int.from_bytes(data[offset:offset+4], "little", signed=True)',
            '                                            length = offset + 4',
            '                                            target = address + length + disp',
            '                                            return {"addr": address, "bytes": "".join(f"{b:02X}" for b in original_data[:length]), "mnemonic": "CALL", "operands": f"0x{target:08X}", "flow": "call"}',
            '                                        elif opcode == 0xE9 and offset + 4 <= len(data):',
            '                                            disp = int.from_bytes(data[offset:offset+4], "little", signed=True)',
            '                                            length = offset + 4',
            '                                            target = address + length + disp',
            '                                            return {"addr": address, "bytes": "".join(f"{b:02X}" for b in original_data[:length]), "mnemonic": "JMP", "operands": f"0x{target:08X}", "flow": "jump"}',
            '                                        elif opcode == 0xEB and offset < len(data):',
            '                                            disp = int.from_bytes(data[offset:offset+1], "little", signed=True)',
            '                                            length = offset + 1',
            '                                            target = address + length + disp',
            '                                            return {"addr": address, "bytes": "".join(f"{b:02X}" for b in original_data[:length]), "mnemonic": "JMP", "operands": f"0x{target:08X}", "flow": "jump"}',
            '                                        elif 0x70 <= opcode <= 0x7F and offset < len(data):',
            '                                            jump_names = ["JO","JNO","JB","JAE","JE","JNE","JBE","JA","JS","JNS","JP","JNP","JL","JGE","JLE","JG"]',
            '                                            disp = int.from_bytes(data[offset:offset+1], "little", signed=True)',
            '                                            length = offset + 1',
            '                                            target = address + length + disp',
            '                                            return {"addr": address, "bytes": "".join(f"{b:02X}" for b in original_data[:length]), "mnemonic": jump_names[opcode-0x70], "operands": f"0x{target:08X}", "flow": "jump"}',
            '                                        elif opcode == 0x89 and offset < len(data):',
            '                                            modrm = data[offset]',
            '                                            offset += 1',
            '                                            reg = (modrm >> 3) & 7',
            '                                            operand, consumed = decode_modrm_simple(modrm, data, offset)',
            '                                            length = offset + consumed',
            '                                            return {"addr": address, "bytes": "".join(f"{b:02X}" for b in original_data[:length]), "mnemonic": "MOV", "operands": f"{operand}, {registers_32[reg]}", "flow": "sequential"}',
            '                                        elif opcode == 0x8B and offset < len(data):',
            '                                            modrm = data[offset]',
            '                                            offset += 1',
            '                                            reg = (modrm >> 3) & 7',
            '                                            operand, consumed = decode_modrm_simple(modrm, data, offset)',
            '                                            length = offset + consumed',
            '                                            return {"addr": address, "bytes": "".join(f"{b:02X}" for b in original_data[:length]), "mnemonic": "MOV", "operands": f"{registers_32[reg]}, {operand}", "flow": "sequential"}',
            '                                        else:',
            '                                            # Unknown instruction',
            '                                            return {"addr": address, "bytes": f"{opcode:02X}", "mnemonic": "DB", "operands": f"0x{opcode:02X}", "flow": "sequential"}',
            '                                    ',
            '                                    # Main disassembly loop',
            '                                    instructions = []',
            '                                    asm_offset = 0',
            '                                    max_insts = 24',
            '                                    ',
            '                                    while asm_offset < len(data2) and len(instructions) < max_insts:',
            '                                        remaining = data2[asm_offset:]',
            '                                        if not remaining: break',
            '                                        ',
            '                                        inst = disasm_single_instruction(remaining, win_addr + asm_offset)',
            '                                        if inst is None:',
            '                                            asm_offset += 1',
            '                                            continue',
            '                                        ',
            '                                        instructions.append(inst)',
            '                                        asm_offset += len(inst["bytes"]) // 2  # Hex byte pairs',
            '                                        ',
            '                                        if inst["flow"] in ["return", "interrupt"]:',
            '                                            break',
            '                                    ',
            '                                    if instructions:',
            '                                        base_event["disasm_instructions"] = instructions',
            '                                        ',
            '                                        # Critical instructions',
            '                                        critical = []',
            '                                        for inst in instructions:',
            '                                            if inst["flow"] in ["call", "jump", "return", "interrupt"]:',
            '                                                addr_str = "0x{:08X}".format(inst["addr"])',
            '                                                instr_str = "{} {}".format(inst["mnemonic"], inst["operands"])',
            '                                                critical.append({"type": inst["flow"], "address": addr_str, "instruction": instr_str, "bytes": inst["bytes"]})',
            '                                        base_event["disasm_critical"] = critical',
            '                                        ',
            '                                        # Analysis',
            '                                        analysis = {"total": len(instructions), "calls": 0, "jumps": 0, "returns": 0, "branches": 0}',
            '                                        for inst in instructions:',
            '                                            if inst["flow"] == "call": analysis["calls"] += 1',
            '                                            elif inst["flow"] == "jump": ',
            '                                                analysis["jumps"] += 1',
            '                                                if inst["mnemonic"] != "JMP": analysis["branches"] += 1',
            '                                            elif inst["flow"] == "return": analysis["returns"] += 1',
            '                                        base_event["disasm_analysis"] = analysis',
            '                                        ',
            '                                        # Exception instruction analysis',
            '                                        for inst in instructions:',
            '                                            if inst["addr"] == addr:',
            '                                                base_event["exception_instruction"] = inst',
            '                                                crash_hints = []',
            '                                                if inst["mnemonic"] in ["MOV", "CMP", "TEST"] and "[" in inst["operands"]:',
            '                                                    crash_hints.append("Memory access instruction - likely access violation")',
            '                                                elif inst["mnemonic"] in ["CALL", "JMP"]:',
            '                                                    crash_hints.append("Control flow instruction - possible invalid jump target")',
            '                                                elif inst["mnemonic"] == "RET":',
            '                                                    crash_hints.append("Return instruction - possible stack corruption")',
            '                                                if crash_hints: base_event["crash_analysis"] = crash_hints',
            '                                                break',
            '                                except Exception as disasm_error:',
            '                                    base_event["disasm_error"] = str(disasm_error)',
            '                                    # Fallback to simple pseudo disassembly',
            '                                    pseudo=[]; i=0; ln=len(data2)',
            '                                    while i<ln and len(pseudo)<16:',
            '                                        op=data2[i]',
            '                                        if op==0xCC: pseudo.append("INT3"); i+=1; continue',
            '                                        if op in (0xE8,0xE9) and i+5<=ln:',
            '                                            tgt=int.from_bytes(data2[i+1:i+5],"little")',
            '                                            pseudo.append((("CALL" if op==0xE8 else "JMP")+"+%08X"%tgt)); i+=5; continue',
            '                                        if op in (0x55,0x53,0x57):',
            '                                            pseudo.append({0x55:"PUSH EBP",0x53:"PUSH EBX",0x57:"PUSH EDI"}[op]); i+=1; continue',
            '                                        pseudo.append(f"OP{op:02X}"); i+=1',
            '                                    if pseudo: base_event["disasm_pseudo"]=pseudo',
            '                    except Exception: pass',
            '                # stack capture if requested and context present',
            '                if not perf_mode and stack_bytes>0 and proc_handle and (base_event.get("context") or base_event.get("esp") or base_event.get("ESP")):',
            '                    try:',
            '                        esp=None',
            '                        ctx=base_event.get("context")',
            '                        if ctx: esp=ctx.get("ESP")',
            '                        if esp:',
            '                            sz=min(stack_bytes,2048)',
            '                            sbuf=(C.c_ubyte*sz)()',
            '                            rs=C.c_size_t()',
            '                            if kernel32.ReadProcessMemory(proc_handle, C.c_void_p(esp), sbuf, sz, C.byref(rs)) and rs.value>0:',
            '                                stack_bytes_raw=bytes(sbuf[:rs.value])',
            '                                preview=min(rs.value,256)',
            '                                base_event["stack_len"]=int(rs.value)',
            '                                base_event["stack_hex"]="".join(f"{b:02X}" for b in stack_bytes_raw[:preview])',
            '                                if rs.value>preview: base_event["stack_truncated"]=1',
            '                                # lightweight stack pointer deref mapping into modules',
            '                                try:',
            '                                    refs=[]',
            '                                    limit=min(len(stack_bytes_raw),256)',
            '                                    i2=0',
            '                                    while i2+4<=limit and len(refs)<16:',
            '                                        val=int.from_bytes(stack_bytes_raw[i2:i2+4],"little")',
            '                                        m=_find_module(val)',
            '                                        if m:',
            '                                            off=val-m["base"]',
            '                                            refs.append({"addr":f"0x{val:08X}","module":m["path"],"offset":f"0x{off:X}"})',
            '                                        i2+=4',
            '                                    if refs: base_event["stack_refs"]=refs',
            '                                except Exception: pass',
            '                    except Exception as _se: base_event["stack_error"]=str(_se)',
            '                # secondary memory region capture (EIP+offset) if extra_mem>0',
            '                if not perf_mode and extra_mem>0 and proc_handle and code_v!=0:',
            '                    try:',
            '                        off_addr=addr+16  # simple forward look',
            '                        sz=min(extra_mem,1024)',
            '                        buf3=(C.c_ubyte*sz)()',
            '                        r3=C.c_size_t()',
            '                        if kernel32.ReadProcessMemory(proc_handle, C.c_void_p(off_addr), buf3, sz, C.byref(r3)) and r3.value>0:',
            '                            b3=bytes(buf3[:r3.value])',
            '                            base_event["extra_mem_len"]=int(r3.value)',
            '                            base_event["extra_mem_base"]=f"0x{off_addr:016X}"',
            '                            base_event["extra_mem_hex"]="".join(f"{x:02X}" for x in b3[:128])',
            '                    except Exception: pass',
            '        except Exception as _exc:',
            '            base_event["detail_error"]=str(_exc)',
            '        # Crash triage: if second-chance and crash_triage enabled add marker',
            '        if code==EXCEPTION_DEBUG_EVENT and base_event.get("first_chance", base_event.get("fc"))==0 and crash_triage:',
            '            base_event["triage"]=1',
            '            # auto enable basic memory if requested and previously off',
            '            if auto_mem_on and mem_bytes==0:',
            '                base_event["auto_mem_trigger"]=1',
            '                # (Heuristic) we did not re-read memory because mem_bytes was 0; future enhancement could re-issue RPM here.',
            '        # Add sequence index & relative ms + severity/explanation for exceptions',
            '        try:',
            '            rel_ms=int((datetime.utcnow()-start_ts).total_seconds()*1000)',
            '            base_event["rel_ms"]=rel_ms',
            '            base_event["idx"]=seen',
            '            if base_event.get("event")=="EXCEPTION":',
            '                en=base_event.get("exception_name") or base_event.get("xn")',
            '                fc = base_event.get("first_chance", base_event.get("fc",1))',
            '                sev = "break" if en=="BREAKPOINT" and fc==1 else ("fatal" if fc==0 else "info")',
            '                base_event["severity"]=sev',
            '                if not compact:',
            '                    explanations={',
            '                        "BREAKPOINT":"Software breakpoint (int3). Often initial loader breakpoint; usually ignore unless repeated.",',
            '                        "ACCESS_VIOLATION":"Process tried invalid memory access (read/write/execute). Investigate av_type + av_address.",',
            '                        "ILLEGAL_INSTRUCTION":"CPU attempted to execute invalid/unsupported opcode.",',
            '                        "INT_DIVIDE_BY_ZERO":"Division by zero occurred.",',
            '                        "STACK_OVERFLOW":"Stack exhaustion (unbounded recursion or huge local allocation).",',
            '                        "FAST_FAIL":"Windows fast fail / security related fast fail (e.g. CFG / GS)."',
            '                    }',
            '                    if en in explanations: base_event["explain"]=explanations[en]',
            '        except Exception: pass',
            '        events.append(base_event); seen+=1',
            '        if stream:',
            '            try:',
            '                line=json.dumps(base_event,ensure_ascii=False)',
            '                print(line); sys.stdout.flush()',
            '                try:',
            "                    with open(out_path, 'a', encoding='utf-8') as fh: fh.write(line+'\\n')",
            '                except Exception: pass',
            '            except Exception: pass',
            '        # Stop on second-chance if requested',
            '        if code==EXCEPTION_DEBUG_EVENT and base_event.get("first_chance")==0 and stop_on_second_chance:',
            '            break',
            '    kernel32.ContinueDebugEvent(dbg.dwProcessId, dbg.dwThreadId, DBG_CONTINUE)',
            '    if code==EXIT_PROCESS_DEBUG_EVENT:',
            '        break',
            '',
            'if stream:',
            '    data=None  # streaming mode (already appended per event)',
            'elif want_csv and events:',
            '    import io, csv as _csv',
            '    b=io.StringIO(); w=_csv.DictWriter(b,fieldnames=events[0].keys()); w.writeheader(); w.writerows(events); data=b.getvalue()',
            'elif want_csv:',
            "    data='No events'",
            'else:',
            '    data="\\n".join(json.dumps(e,ensure_ascii=False) for e in events)',
            '',
            'try:',
            '    if data is not None: open(out_path, "w", encoding="utf-8").write(data)',
            'except Exception: pass',
            '',
            'if not stream: print(data)',
            '# Append module summary as separate JSON line if JSONL mode and summary enabled',
            'if not want_csv and module_summary and not stream:',
            "    print(json.dumps({'ts':datetime.utcnow().isoformat()+'Z','event':'MODULE_SUMMARY','module_count':len(modules),'modules':modules},ensure_ascii=False))",
            'elif not want_csv and module_summary and stream:',
            "    summ={'ts':datetime.utcnow().isoformat()+'Z','event':'MODULE_SUMMARY','module_count':len(modules),'modules':modules}",
            '    try:',
            '        js=json.dumps(summ,ensure_ascii=False); print(js)',
            "        with open(out_path, 'a', encoding='utf-8') as fh: fh.write(js+'\\n')",
            '    except Exception: pass',
        ]
        lines.extend(body_lines)
        script = '\n'.join(lines) + '\n'
        script_path = self._create_script(script)
        keep = os.environ.get('WDB_KEEP_SCRIPT') == '1'
        if keep:
            print(f"[debug] generated script: {script_path}")
        try:
            output = self._run_script(script_path, wait_timeout_ms=timeout, wall_timeout_sec=wall_timeout)
            return output.strip()
        finally:
            if not keep and os.path.exists(script_path):
                os.unlink(script_path)

    # (Removed auxiliary execute_python_code / cleanup helpers; not used externally)
